import kotlinx.coroutines.*
/*
    1. runBlocking开辟了一个协程，但是会阻塞当前的线程，下例就是main线程；而launch不会阻塞当前线程；
    2. 如果一个 launch { ... } 代码块内部完全没有调用任何挂起函数 (suspending functions)，那么它的行为会
        变得非常确定：该 launch 块内的所有代码，将会从头到尾、顺序地在同一个线程上执行完毕。
    3. launch 的本质:
        （1）launch 创建一个协程任务 (Coroutine Task)。
        （2）调度器 (Dispatcher) 负责决定这个任务初始在哪个线程 (Thread) 上开始执行（通常来自一个线程池）。
        （3）关键区别在于挂起： 当协程遇到挂起点（如 delay）时，它可以暂停执行并脱离当前线程，将线程还给调度器
            去执行其他任务。它不是一直霸占着那个线程。当挂起结束后，调度器会再找一个（可能是之前的，也可能是另一个）
            线程来恢复协程的执行。
        （4）线程是执行的基本单位，而协程是在线程之上、由库（和编译器）管理的更轻量级的逻辑控制流单元。 协程可以
            在不同的线程之间 “漂移”（通过调度器切换）。
     4. 线程与协程
        （1） 传统线程的“重量级”资源消耗：
            * 独立的调用栈：每个线程拥有<独立的方法调用栈>，通常需要预分配大量内存（如 512KB 至 1MB）。
            * 上下文切换开销：线程切换需保存和加载 CPU 状态，<涉及操作系统资源>，开销较大。
        （2）协程的“轻量级”原理：
            * 用户态管理： 协程的调度由 Kotlin <协程库和编译器在用户态>完成，<多个协程可共享线程>。
            * 状态机实现： 编译器将协程代码转换为<状态机对象:kotlin对象>，保存局部变量和执行状态，挂起点恢复
                         通过 `resumeWith` 方法实现。
            * 内存占用小： 状态机对象存储在<堆>上，占用内存<远小于线程调用栈>。
            * 高效切换： <协程切换开销接近函数调用>，远低于线程切换。
        （3）总结：协程因无需独立栈内存且切换开销小，支持创建大量协程，适合处理高并发任务。其轻量特性
                  源于编译器优化和用户态调度。
 */
fun main() =  runBlocking {
    repeat(10){
        launch{
            delay(5000)
            println(".")
        }
    }
}